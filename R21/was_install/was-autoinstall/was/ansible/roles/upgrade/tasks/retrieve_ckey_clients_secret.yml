---
# APPFW-602: we need to reuse existing client secrets instead of generating new ones at every install. The following tasks retrieve
# all Keycloak clients in our realm, and then retrieves the secrets for those clients that this playbook has been tasked with
# configuring in k8s but already exist in Keycloak. Finally new secrets are generated where needed.
- name: Get Keycloak host
  shell: kubectl get secret -n {{ BP_CONFIG_NAMESPACE }} ckey-configurator-config -o jsonpath={.data.keycloak-host} | base64 -d
  register: ckey_host

- name: Get Keycloak port
  shell: kubectl get secret -n {{ BP_CONFIG_NAMESPACE }} ckey-configurator-config -o jsonpath={.data.keycloak-port} | base64 -d
  register: ckey_port

- name: Set Keycloak Admin REST API URL fact
  set_fact:
    ckeyUrl: "https://{{ ckey_host.stdout }}:{{ ckey_port.stdout }}/auth"

- name: Get Keycloak admin client ID
  shell: kubectl get secret -n {{ BP_CONFIG_NAMESPACE }} ckey-configurator-config -o jsonpath={.data.keycloak-admin-client-id} | base64 -d
  register: ckey_admin_client_id

- name: Get Keycloak userid
  shell: kubectl get secret -n {{ BP_CONFIG_NAMESPACE }} ckey-configurator-config -o jsonpath={.data.keycloak-admin-user} | base64 -d
  register: ckey_admin_username

- name: Get Keycloak password
  shell: kubectl get secret -n {{ BP_CONFIG_NAMESPACE }} ckey-configurator-config -o jsonpath={.data.keycloak-admin-password} | base64 -d
  register: ckey_admin_password

- name: Get a token from Keycloak using the admin-cli client
  uri:
    validate_certs: no
    url: "{{ ckeyUrl }}/realms/master/protocol/openid-connect/token"
    method: POST
    body_format: form-urlencoded
    body:
      client_id: "{{ ckey_admin_client_id.stdout }}"
      username: "{{ ckey_admin_username.stdout }}"
      password: "{{ ckey_admin_password.stdout }}"
      grant_type: "password"
    use_proxy: no
  register: ckey_token

- name: Retrieve netguard Keycloak clients
  uri:
    validate_certs: no
    url: "{{ ckeyUrl }}/admin/realms/{{ CKEY_REALM_NAME }}/clients"
    method: GET
    headers:
      Authorization: "bearer {{ ckey_token.json.access_token }}"
    use_proxy: no
  register: ckey_clients

- name: Build a dictionary of existing Keycloak clients' UUIDs
  set_fact:
    ckey_client_uuid_dict: "{{ ckey_client_uuid_dict|default({}) | combine( {item.clientId : item.id} ) }}"
  with_items: "{{ ckey_clients.json }}"
  no_log: true

- name: Retrieve existing Keycloak client secrets
  uri:
    validate_certs: no
    url: "{{ ckeyUrl }}/admin/realms/{{ CKEY_REALM_NAME }}/clients/{{ ckey_client_uuid_dict.get(item.ckey_client_name) }}/client-secret"
    method: GET
    headers:
      Authorization: "bearer {{ ckey_token.json.access_token }}"
    use_proxy: no
  with_items: "{{ ckey_client_secret_helm_param_names }}"
  when: item.ckey_client_name in ckey_client_uuid_dict
  register: ckey_secrets_retrieval_reg

- name: Build a dictionary from the client secrets retrieved from Keycloak
  set_fact:
    secret_dict: "{{ secret_dict|default({}) | combine( {item.item.helm_param_name : item.json.value} ) }}"
  with_items: "{{ ckey_secrets_retrieval_reg.results }}"
  when: item.skipped is not defined or item.skipped == false
  no_log: true

- name: Generate secrets for the new clients being added
  with_items:
    - "{{ ckey_client_secret_helm_param_names }}"
  set_fact:
    secret_dict: "{{ secret_dict|default({}) | combine( {item.helm_param_name : 99999999999999999995 | random | to_uuid} ) }}"
  when: item.ckey_client_name not in ckey_client_uuid_dict
  no_log: true

- name: Add secrets to Helm params
  set_fact:
    helm_params: "{{ helm_params }} --set {{ item.key }}='{{ item.value }}'"
  with_dict: "{{ secret_dict }}"
  no_log: true

