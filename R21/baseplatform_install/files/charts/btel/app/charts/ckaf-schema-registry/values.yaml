# Default values for Confluent Schema-Registry
# This is a YAML-formatted file.
# Declare name/value pairs to be passed into your templates.
# name: value
global:
  # This registry is used for schema-registry container image
  registry: csf-docker-delivered.repo.lab.pl.alcatel-lucent.com
  # This registry is used for jmx-exporter container image
  registry1: csf-docker-delivered.repo.lab.pl.alcatel-lucent.com
  # This registry is used for cbur container image
  registry2: csf-docker-delivered.repo.lab.pl.alcatel-lucent.com
  # This registry is used for schema-registrytest container image
  registry3: csf-docker-delivered.repo.lab.pl.alcatel-lucent.com
  # This registry is used for kubectl tool  image
  registry4: csf-docker-delivered.repo.lab.pl.alcatel-lucent.com
  # Enable this flag to forcefully upgrade Schema-registry
  forceUpgrade: true
  # Enable this flag to prepare kafka for rollback
  prepareRollback: false
  storageClass: ""
  rbacEnable: true
  preheal: 0
  postheal: 0
  #CLOG configuration
  clogEnable: true
  seccompAllowedProfileNames: docker/default
  seccompDefaultProfileName: docker/default

#This section allows to configure user defined name for component resources
# Options include:
# nameOverride: use this to have 'ckaf-sr'-'user-defined' naming convention.
# fullnameOverride: use this to have custom name for all the resources.
# default (below parameters commented): <releasename>-ckaf-schema-registry naming convention.
# If specified both, fullnameOverride would take the precedence.

#nameOverride: "user-defined"
#fullnameOverride: "user-defined"

# By Default uses Release Name, but can be overridden.  Which means each release is its own group of
# Schema Registry workers.  You can have multiple groups talking to same Kafka Cluster
overrideGroupId: ""

## Number of Schema Registry Pods to Deploy
replicaCount: 1

#Job time out for Scale Event
jobtimeout: 60

#livenessProbe and readinessProbe delay and timeout values
livenessProbe:
  initialDelaySeconds: 50
  timeoutSeconds: 300
readinessProbe:
  initialDelaySeconds: 50
  timeoutSeconds: 300

##Schema Registry
SchemaRegistry:
  image:
    name: ckaf/schema-registry
    tag: 4.0.0-5.4.1-3591
    pullPolicy: "IfNotPresent"
  cubtimeout: 5000

# Add user defined label under nodeLabel as key value pair.
# Enable it to true to use nodeLabel feature
# Always quote the value part. Example nodeType: "sr-enable"
# Example:
# SchemaRegistryNodeSelector:
#   enable: true
#   nodeLabel:
#     "key1" : "value1"
SchemaRegistryNodeSelector:
  enable: false
  nodeLabel:

# Enable tolerationsForTaints and provide toleration
# toleration can be added for three types of taints : NoSchedule, PreferNoSchedule and NoExecute
# operator can also be given as Exists and value parameter can be omitted in that case
# tolerationSeconds (in seconds) can be added as part of NoExecute toleration that specifies how long the pod will stay bound after the node tainting.
# Multiple tolerations can be added
# Example: 
# - key: "testing1"
#   operator: "Equal"
#   value: "no1"
#   effect: "NoSchedule"
# - key: "testing2"
#   operator: "Exists"
#   effect: "NoExecute"
#   tolerationSeconds: 120
# toleration matches a taint if key and effect is same. 
# An empty 'key' with operator Exists will tolerate everything as it matches all keys, values and effects.
# Example: 
# - operator: "Exists"
# An empty 'effect' matches all effects with key 'key'
# Example:
# - key: "key"
#   operator: "Exists"
tolerationsForTaints:
    enable: false
    tolerations:
      - key: <"key1">
        operator: <"Equal">
        value: <"val1">
        effect: <"NoSchedule">
## JMX exporter
JmxExporter:
  image:
    name: cpro/jmx-exporter
    tag: v2.0.0
    pullPolicy: IfNotPresent
  port: 32000
LogLevel: "INFO"
MaxFileSize: 100MB
MaxBackupIndex: 10

KubectlTool:
  image:
    name: tools/kubectl
    tag: v1.10.3
    pullPolicy: IfNotPresent

##Schema Registry Helm Test
SchemaRegistryTest:
  image:
    name: ckaf/schema-registrytest
    tag: 1.0.0-503
    pullPolicy: "IfNotPresent"

## Schema Registry Settings Overrides
## Configuration Options can be found here: https://docs.confluent.io/current/schema-registry/docs/config.html
configurationOverrides:
   kafkastore.topic.replication.factor: 3
   heap_opts: "-Xmx512M"
   jvm_performance_opts: "-server -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:+ExplicitGCInvokesConcurrent -Djava.awt.headless=true" 

## Configure resource requests and limits
## ref: http://kubernetes.io/docs/user-guide/compute-resources/
## Confluent has production deployment guidelines here:
## ref: https://github.com/confluentinc/schema-registry/blob/master/docs/deployment.rst
resources:
   limits:
    cpu: 2
    memory: 2Gi
   requests:
    cpu: 2
    memory: 2Gi
jmxresources:
   limits:
    cpu: 1
    memory: 4Gi
   requests:
    cpu: 500m
    memory: 2Gi
jobresources:
   limits:
    cpu: 1
    memory: 4Gi
   requests:
    cpu: 200m
    memory: 1Gi

## The port on which the SchemaRegistry will be available and serving requests
servicePort: "8081"

#  overrideBootstrapServers: "PLAINTEXT://kafka-test-ckaf-kafka-headless:9092"
## Additional Java arguments to pass to Kafka.
# schemaRegistryOpts: -Dfoo=bar

# Options for connecting to SASL kafka brokers
sasl:
  enable: false
  #sasl.mechanism: possible values "GSSAPI" or "PLAIN"
  mechanism: "GSSAPI"
  scram:
    enabled: false
  #krbConf value: cat ./krb5.conf | base64 | tr -d '\n'
  #sudo kubectl create secret generic <secret-name> --from-literal=krbPrincipalKey=<client-principal-name> --from-file=krbKeytabKey=/path/to/client-keytab
  krb:
    # provide the krb5.conf as a configmap
    # kubectl create configmap <krbConfigmapName> --from-file=<KrbConfKeyName>=<path to krb5.conf>
    krbConfigmapName: 
    KrbConfKeyName: 
    krbSecretName: <user created secret's name>
    krbPrincipalKey: <user to fill krbPrincipalKey>
    krbKeytabKey: <user to fill krbKeytabKey>
  plain:
    secretName: 
    usernameKey: 
    passwordKey: 

sr_ssl:
##K8s Secret doc: https://kubernetes.io/docs/concepts/configuration/secret/
###K8s Secret name defined by user. A single secret object has to be created which conatins 5 secret keys
###out of which 2 keys are created for certificate files (Keystore and Trustore) and 3 keys are created
###for SSL certificates peasswords (Keystore, Keystore key and Truststore password).
###Example K8s secret command:
###kubectl create secret generic <secret-name> --from-literal=keypass=<passwd>--from-literal=kstpass=<passwd> --from-literal=storepass=<passwd>--from-file=<certificatepath>/ca.truststore --from-file=<certificatepath>/kube1.keystore
  enabled: false
  secret_name: <user to put according to configured Kubernetes secret name>
  keystore_key: <user to fill for schema registry>
  truststore_key: <user to fill for schema registry>
  truststore_passwd_key: <user to fill for schema registry>
  keystore_passwd_key: <user to fill for schema registry>
  keystore_key_passwd_key: <user to fill for schema registry>
  # Configures schema registry to request client authentication.
  # To enable set it to true
  clientAuth: false
  # To enable the http listener when schema registry SSL is turned ON, need to specify the port
  # if no port is specified the "http listener" will not be available.
  # for eg: http_listener.servicePort: "8016"
  http_listener:
    servicePort: ""

# Schema Registry can be configured to require users to authenticate using a username and password 
# via the Basic HTTP authentication mechanism.
# to enable set sr_basicAuth.enabled: true
# "authenticationRoles "config defines a comma-separated list of user roles. 
#   To be authorized to access Schema Registry, an authenticated user must belong to at least one of these roles.
#   For eg: authenticationRoles: "admin,developer,user,sr-user"
# Passwd file can contain multiple users, and user should be mapped to any one of the authentication.roles and provide as secret
# kubectl create secret generic <secretName> --from-file=<secretKeyName>=<path_to_passwd_file>
sr_basicAuth:
  enabled: false
  secretName:
  secretKeyName:
  authenticationRoles: ""


kafka:
  # Either of BootStrapServers or ZookeeperUrl must be provided for primaryi master Election.
  # Provide list of all brokers, in BootStrapServers e.g.:
  # BootStrapServers: "PLAINTEXT://kf-testexternalkafka-headless.default.svc.cluster.local:9092"
  # if SASL/SSL is enabled, then BootStrapServers list must be list of all brokers, with a valid listener name. for eg.:
  # "SASL_PLAINTEXT://kf-kafka351-0.kf-kafka351-headless.default.svc.cluster.local:9092,SASL_PLAINTEXT://kf-kafka351-1.kf-kafka351-headless.default.svc.cluster.local:9092"
  # ZookeeperUrl: zk-testexternalkafka.default.svc.cluster.local:2181
  BootStrapServers: ""
  ZookeeperUrl: ""


kafkastore_ssl:
##K8s Secret doc: https://kubernetes.io/docs/concepts/configuration/secret/
##K8s Secret name defined by user. A single secret object has to be created which conatins 5 secret keys
##out of which 2 keys are created for certificate files (Keystore and Trustore) and 3 keys are created
##for SSL certificates passwords for kafka client (Keystore, Keystore key and Truststore password).
  enabled: false
  secret_name: <user to put according to configured Kubernetes secret name>
  keystore_key: <user to fill for kafkastore client>
  truststore_key: <user to fill for kafkastore client>
  truststore_passwd_key: <user to fill for kafkastore client>
  keystore_passwd_key: <user to fill for kafkastore client>
  keystore_key_passwd_key: <user to fill for kafkastore client>

##Non root user configurations for schema registry - default user-id populated as recommeded by confluent schema registry
Security:
  enabled: true
  runAsUser: 999
  fsGroup: 998


ingress:
  ## Enable this feature for external access 
  enabled: false
  hostName: ""
  tls:
    enabled: false
    secretName: ""

lcm:
  scale_hooks: all
  scale_timeout: 720

# Upgrade config
enable_upgrade_hook: false
# Rollback config
enableRollback: false
